[{"title":"Docker 技术概述","path":"/2021/04/02/docker-introduction/","content":"概要本文从一个概览的角度，介绍下 Docker 技术的核心优势、技术原理和相关的组件。 主要从以下几个方面来了解： 为什么用 Docker？ 了解 Docker 能干什么 了解 Docker 和其他方便比有什么优势 Docker 的技术原理 Docker 本身的架构设计 Docker 底层所依赖的关键技术 Docker 集群的简单介绍 为什么使用 Docker让我们带着几个核心问题出发。问题从动机开始，而不是从“是什么”来开始： Docker 主要解决了什么问题？ 在有 Docker 之前有其他的解决方案吗？ Docker 有什么优势？ 解决了什么问题本质是快速的分发部署应用。在云时代，应用需要方便地在网上传播，就是说需要脱离硬件资源的限制，同时能够容易地获取。 设想我们有一个简单的 Web 服务器应用，它基于 Ngnix、Java、MySQL 来开发实现。现在用户需要把它部署到自己的机器上，那么用户需要安装所需要的各种软件和依赖，并对它们进行配置，然后进行一系列的测试验证确认它们是否能够协同工作。这些步骤中很可能因为本地环境的不同遇到各种奇怪的问题，应用的传播十分复杂。 Docker 使用了一种很聪明的方式，通过镜像来把整个应用打包，将应用和运行平台解耦，再集中地管理和分发镜像。 Docker 的官网有一份简述 Why Docker，总的来说就是： 目前的软件开发需要使用各种各样的语言、架构、框架和工具，带来了很大的复杂性，Docker 的目标就是简化和加速这个工作流。主要有以下几个方面： 让构建、分享、运行变得简单 提高开发运维的整个流程的效率，保证运行的一致性 团队合作更加高效 Docker 与虚拟机对比Docker 之前怎么解决前面的问题？ Docker 是一种容器引擎，容器是一种轻量级的虚拟化技术，在这之前主要的虚拟化技术是虚拟机。 容器和虚拟机有什么区别？ 容器：容器和宿主系统共用同一个内核空间，利用了内核提供的资源隔离和资源限制的能力，直接使用宿主机的资源。 虚拟机：通过 Hypervisor 层来模拟硬件，在它上面安装完整的操作系统，应用再运行在虚拟的 Guest OS 中。 它们的特性对比如下： 特性 容器 虚拟机 启动时间 秒级 分钟级 镜像存储 KB~MB GB~TB 系统资源 0~5% 5~15% 系统支持量 单机支持上千个容器 一般几十个 总的来讲，Docker 的主要优点有： 轻量：秒级的启动和停止。 更高效的虚拟化：占用更少的系统资源。 扩展性：运行在各种平台上，本地、物理机、云端，能够很轻松的迁移。 更简单的管理和分发：镜像的大小比较小，并且通过增量的方式更新和分发，更加高效。 Docker 技术原理Docker 架构Docker 使用了 CS 架构。Client 通过命令和 deamon 交互，deamon 负责具体的镜像拉取、容器构建运行等。Client 和 deamon 可以在同一个系统中，也可以将 deamon 部署在远端。 架构主要分为三个部分： Docker deamon: Docker 服务端进程，又叫 dockerd。它监听端口的命令，提供 REST API 来管理镜像、容器、网络、volume 等，同时还可以和其他的 docker demon 交互来管理 docker 服务。 Docker client: Docker 客户端，提供命令来让用户和 deamon 交互。客服端发送用户输入的命令到服务端，deamon 执行这些命令。 Docker registry: 集中存储、分发 Docker 镜像的服务，Docker deamon 从指定 registry 上拉取镜像。 基本概念Docker 有三个基本概念： Image（镜像）：镜像就是一个只读的模板，用来创建容器。它是一个特殊的文件系统，包含了程序运行所需要的库、资源、配置文件、环境变量等。它是静态不可变的，不包含动态产生的任何数据。 Container（容器）：容器就是镜像的一个运行时实例，它以镜像为基础，在上面创建一层容器的储存层，是运行在独立命名空间中的一个进程。它可以被创建、启动、关闭、重启等。 Repository（仓库）：Docker Registry 是提供镜像的集中式的存储、分发的服务，它可以包含多个 Repository (仓库)，每个仓库有可以有多个 tag (标签)，其中每个标签就对应了一个镜像。 总结来说就是，镜像是静态的不可变的，而容器是镜像的运行实例，它们有点像面向对象编程中的类和对象的关系，而仓库就是存储和分发镜像的地方。 底层原理使用容器的一个核心目的就是，每次容器的运行能够独立并且稳定。即在宿主机上启动多次，或者在不同的宿主机上迁移，运行的效果是一样的。 那怎么样才能让每次的运行的效果是一样的？可以从两个方面来考虑： 部署一致性： 应用的打包要包含应用的完整依赖，包括文件、配置、依赖库等，即镜像中需要有应用完整的依赖。 执行一致性： 希望容器每次运行时看到相同的计算机的“视图”。不会因为宿主机上运行着不同的进程，有着不同的文件而受到影响。 宿主机上可能同时运行着多个容器，为了保证容器的运行稳定，同时保证宿主机的运行稳定。那么就要限制单个容器使用的资源，如 CPU、内存、网络、硬盘 IO 等，防止一个容器占用资源过多影响到宿主机，从而影响到其他容器。 Docker 主要通过以下底层技术实现了前面的两种一致性： 部署一致性：rootfs Union FS 执行一致性：namespace cgroups rootfs Union FS容器的静态依赖是通过镜像来支持的，镜像中包含了容器所需要的完整依赖。那么一个容器通常会有什么依赖呢？ 最直观想到的部分，应用程序二进制文件本身和它依赖的语言库、配置等。 容易被忽略的部分，应用运行的操作系统，是容器完整的“依赖库”。 典型的 Linux 文件系统由两部分组成： bootfs: 操作系统的内核 rootfs: 操作系统包含的所有配置、文件和目录 容器镜像通过打包一个 rootfs，提供了“打包操作系统的能力”，让操作系统这个最基础的“依赖库”保持稳定，从而保证了容器的部署一致性。 那么容器只需要在 rootfs 基础上，再将应用程序、依赖的语言库、配置等增加上去，就能够保证依赖的稳定性。但是直接在 rootfs 上不停的修改有什么缺点呢？ 缺少复用性：每次安装一些不同的程序软件，都会打包出一个新的 rootfs，这些 rootfs 之间没有关联，无法复用。（可以把它们想象成两个完全无关的 Git 仓库，即使代码相同也无法 merge） 容器镜像使用了联合文件系统（Union FS）来解决这个问题，它通过分层，将每次修改差量的部分作为新的层存储下来。 Docker 镜像是通过分层构建的，其中每一层都是只读的。当容器运行时，会在最上层提供了一个可读写入层用来写入数据。如下图所示： namespace cgroups为了容器执行的一致性，需要 Linux 的以下两种技术： namespace: 为容器提供资源隔离能力，给应用创建了一个“边界”，让应用只能看到 namespace 内的“世界”。 cgroups: 资源限制的能力，限制容器的边界，让容器占用的资源是可控的。 Namespace 是 Linux 创建进程时的一个可选参数，因此容器其实也只是一个特殊的进程。其中 Linux 主要支持了 6 种 namespace 来进行各种资源隔离，基本上覆盖了进程运行所需要的主要的资源： Namespace 系统资源 容器中的隔离效果 UTS 主机信息 每个容器可以有自己的主机和域名，在网络上可以被视为独立的节点，而非宿主机的一个进程 IPC 进程间通信 同一个 IPC namespace 下的进程才彼此可见 PID 进程 每个 PID 命名空间中进程可以有独立的 PID，如每个容器可以有它的 PID 为 1 的 root 进程 Mount 文件系统挂载点 每个容器能看到不同的文件系统层次结构 Network 网络 每个容器有独立的网络设备，IP 地址、IP 路由表、端口号等，如同一台宿主机上多个容器的应用都能使用 80 端口 User 用户 容器能够拥有和宿主机独立的 user 和 group 但是 namespace 隔离机制也有不足之处，隔离的不够彻底。比如时间就不支持 namespace 隔离，容器修改了宿主机的时间，会影响到宿主机上的其他容器。 cgroups 是 Linux 对进程提供资源限制的手段。其中有几个核心概念： subsystem（子系统）：代表 Linux 能提供限制的一种资源，如 CPU、内存、硬盘 IO 等。 cgroup（控制组）：一组任务和子系统的关联关系，表示对任务进行怎样的资源限制。是一个中间的结构，与多个进程关联，可以理解成一个进程组，主要是为了方便管理，让一组进程能够受到某几个子系统的限制。 hierarchy（层级树）：一组 cgroup 形成的树结构，子节点会默认的继承父节点的属性。这种继承主要是为了方便使用，如在限制的基础上继续限制。 task（任务）：对应系统中的一个进程，与 cgroup 进行多对多关联。 cgroups 实现的本质是给进程挂上钩子（hook），当进程（task）运行时涉及到某个资源时， 就会触发钩子上附带的 subsystem 进行检测和限制。 Linux 主要提供了以下 subsystem： cpu, cpuacct: cpu 主要限制进程 cpu 使用率，cpuacct 统计 cgroups 中进程的 cpu 使用报告。 cpuset: 指定任务能运行在哪个核上。 blkio: 限制块设备（磁盘、SSD、USB 等）的 IO 速率 devices: 限制 cgroup 中任务对设备的访问。 net_cls: 为 cgroup 中任务的报文加上特殊的标记，这样工具就能针对网络进行配置。 net_prio: 对网络接口设置优先级。 memory: 限制 cgroup 的内存使用，并生成任务的使用情况报告。 子系统的隔离也有一些不足之处，比如内核 3.x 中，硬盘通过 Buffer IO 写入时，内核缓冲区没有进行隔离，高 IO 的进程很容易影响到其他进程。内核 4.x 中 cgroups v2 对此作了改进。 扩展问题： 容器本质是一个进程，那怎么样支持多进程服务？ 可以通过启动子进程，使用同样的 namespace。那么父进程就需要是一个启动其他进程的程序或脚本，如 supervisord、runit。 为什么最佳实践是容器中只启动一个进程？ 尽量的使用单进程容器，因为 Docker 就相当于一个守护进程，它能很好的管理进程，如 “docker ps” 了解进程状态等。如果使用 supervisord，相当于你自己维护了子进程的状态，容器并不知道，这无疑增加了容器的维护成本和不稳定性。 另外从设计哲学上，容器提供单一的功能有很多优点，参考这里。 Docker 从单机到集群我们将单体应用拆分为细小的服务，运行在各个容器中。那么如何部署、管理、扩展这么多的容器？ 容器编排就是用来管理容器集群的方式，从“容器”变成了“容器云”。 容器编排的工具，最具代表性的有： Docker 公司的 Compose + Swarm Google 主导的 Kubernetes，现在已成为容器编排的事实标准了。 简单的介绍下它们的区别： Docker Compose: 允许你配置和启动多个 Docker 容器，用于在同一主机上管理多个容器。 Docker Swarm: 用于在多个主机上运行和连接 Docker 容器，并且提供一些扩展管理，如容器崩溃时启动新容器等，即一个容器集群管理和编排的工具。 Kubernetes: 也是一个容器管理和编排的工具， Kubernetes 从更宏观的高度，用统一的方式定义任务间的关系，用 Pod 和 Service 等统一抽象，提供了更强大的编排能力。","tags":["技术"],"categories":["技术"]},{"title":"为 Github Pages 绑定个人域名","path":"/2019/01/17/github-pages-custom-domain/","content":"2020-12-27 更新：由于使用频率比较低，域名到期后不再续期，继续寄人篱下。 一直用着免费的 Github Pages 搭载个人博客，突然想要一个自己的域名。个人域名的主要优点有： 方便记忆，也就更方便传播 使用别人的二级域名，总是寄人篱下，还是有个自己的一亩三分地比较好 然后就去为博客绑定了个人域名，下面讲述下主要流程。 主要流程如下： 选择一个域名提供商并购买域名 配置 DNS 信息 配置 Github Pages CNAME 信息 购买域名可以选择国内或国外的域名提供商来购买域名，国内通常需要个人实名备案，下面是一些常用的域名商： 国内的域名商：阿里云、腾讯云 国外的域名商：Godaddy、Dynadot 我选择使用 Dynadot 作为我的域名提供商，在主页搜索你想要的域名，如果还没有被他人注册，选择购买即可。 配置 DNS为你的域名配置 DNS 信息。配置域名 DNS 时，有很多种配置方式，我期望的效果是： 使用主域名作为主要的网站地址 www 的子域名重定向到主域名，即访问 www 子域名时，跳转到主域名（浏览器地址中展示主域名） 强行跳转到 HTTPS 域名 以 Dynadot 为例，选择「My Account - My Domains - Manage Domains - Select your domain - DNS Settings - Custom DNS」，然后： 在 Domain Record 下添加一个 CNAME 指向你的 Github Pages 地址 username.github.io 在 Subdomain Records 下添加 Forward 301 记录，将 www 子域名重定向到 https://yourdomain.com 通常主域名是不建议使用 CNAME 跳转的，因为 DNS 规范中返回 CNAME 时，不允许和其他 Resource Record 一起返回，它可能会造成一些问题，详情可以参考这篇文章。但如果你又不想配置 A 记录（改变 IP 时不太方便），你可以使用 ALIAS、ANAME，不过 Dynadot 只支持 CNAME 或者 A 记录，所以我还是选择了配置 CNAME。 配置 Github Pages完成 DNS 的配置后，还需要在你的 Github Pages Repo 中增加一个 CNAME 文件，文件的内容为你使用的域名地址（不要 http 前缀），只能添加一条。例如可以配置为： yourdomain.com Github 会根据你配置的 CNAME，自动为你做 www 子域名的重定向，你也可以使用 DNS 配置的重定向。 感谢 Let’s Encrypt 让我们能够用上开源免费的 HTTPS 证书，Github Pages 也默认对它支持。简单的在 Repo 的「Settings - GitHub Pages - Enforce HTTPS」打钩开启，即可完成 HTTPS 的配置。","tags":["博客"],"categories":["技术"]},{"title":"了解番茄工作法","path":"/2018/11/17/the-pomodoro-technique/","content":"写在前面很早就知道番茄工作法，但一直都没有认真的去了解过。最近想要改善下拖延的习惯，并提高做事的效率，就去读了《番茄工作法图解》一书。 先聊一聊自己最近的状态。通常下班已经很晚了，工作了一整天后，人比较累，很难开始做一些需要思考的事情，很多时候就是漫无目的地看些比较休闲的视频，然后就睡觉了。适当的放松和休息当然是必要的，但是如果在一个很长的时间段，精力都只放在工作中，而不能做一些自己想做的其他事情，会让人感到焦虑，觉得没能做一些有意义的积累。那么如何打破这种惯性，开始做一些想做的事情呢？番茄工作法就是一个很好的工具，它主要有以下的优点： 摆脱拖延。因为懒惰或者完美主义不愿意开始，那么就强行开始。番茄工作法想要培养一种习惯，一种按下按钮，就必须要进行一个25分钟高效周期的习惯。这样高效的做事，就转变成了开启一个番茄，按下一个按钮，变成了一个容易开始的过程。 提高对自我效率的认知。自己要多久才可以做完某件事情？生活中、工作中有大量的场景需要评估一个事情所需要花费的时间代价，了解自己的效率，对制定计划和任务拆解，都有很大的帮助。番茄工作法通过记录和复盘自己在一个番茄内完成的事情，让你逐渐地量化自己的效率。 番茄工作法的理论什么是番茄工作法？简单的讲就是一次只做一件事，每次25分钟，做完就休息。 为什么叫番茄工作法？方法的创立者弗朗西斯科·西里洛在大学的时候，因为自己的效率低下很痛苦，跟自己打赌要“真正的学上10分钟”，就从厨房找了一个计时器，形状好像“番茄”，这就是后来的番茄钟。 为什么要用番茄工作法？番茄工作法有以下的特征优点，或能解决以下的问题： 复杂无聊的琐事完美主义容易造成拖延 按照事情的优先级处理事情 建立一种节奏感，能够拥有的工作休息节奏 记录、处理和可视化，个人流程能够持续改进 增强你做计划的能力，数据化你的效率 它很简单，需要的工具很简单，流程很简单 番茄工作法的一些心理学原理：生物节律、条件与非条件反射、工作记忆、心流、拖延。 怎么应用番茄工作法？番茄工作法实践起来很简单，流程为指定计划-准备环境-吃“番茄”-记录分析修正。更具体的说就是： 从活动清单中选择今天需要完成的任务到今日待办。 从今日待办中选择优先级最高的任务，开始一个番茄钟，并记录一些跟踪信息。 一天结束后，根据记录表格，可视化记录数据，分析流程是否有改进的方式，调整每日的流程。 这是一个戴明循环的流程，一个可以自我优化的循环流程。戴明循环（PDCA 循环）是一种解决问题的周期流程，主要分为4步： 计划（Plan）：定义预期的结果，以及达成它所需的流程。 执行（Do）：实施该流程。 评估（Check）：对流程进行衡量，比较实际结果与预期结果，找出差距。 应用（Action）：对差距进行分析，找出问题根源，以图改进。 番茄工作法只需要一些简单的工具。假如用传统的方式来记录，可以使用一只签字笔、三张白纸和一枚番茄钟即可。三张白纸用途如下： 「今日待办」表格：填写今天的日期和今天需要进行的活动。每天使用一张新的白纸。 「活动清单」表格：列出最近所有需要进行的活动，随便填写，不用排序。一张活动清单可以用很多天，增加新的活动，划掉已完成的活动。 「记录」表格：记录各种流程指标，以便对流程进行改进。一张记录表格可以用很多天，以便比较每天的跟踪信息。 在现在的电子化时代，我选择用一些软件做作为替代品，主要用了下列软件： Apple Calendar：日历是神圣的，主要用来规划一些重要的（必须要做）的事情；不过我专门分出了一个“奇特的一生”日历用来记录流水账，可以记录番茄的信息方便追踪。 Microsoft TODO：用来做任务管理，即取代今日待办和活动清单 Forest：完成一个番茄后种树，可以方便的分类记录和总结回顾，另外看着种出来的森林也是件惬意的事情。 以前内心比较抵制各种激励机制，认为靠理性与自控是更好的方式，现在逐渐接受通过激励、仪式感、趣味性来提高自己的执行力。Permission to be human. Human nature 不是你的敌人，我们应该去接受它，而不是抵制它，用一种更好的方式和它相处（比如学会奖赏你的努力，而不是只依赖自己的自制力）。使用 Forest，每次番茄成功后能种一颗虚拟的树，一点一点种出来一片森林，是一件挺开心的事。 番茄钟是原子的，也就是说一次只做一件事，并且不能被中断。这两个原则可能会遇见一些问题，下面是这些问题和应对方法： 如果提前（番茄钟未结束）做完了手中的事情，可以通过过度学习加强下之前内容的理解，不要在番茄内切换任务。 对于一些很小的零碎任务，可以合并到一个番茄钟内，作为一个整体任务，另外应该减少这种零碎任务番茄。 当遇见中断的时候，对于内部中断，先记录下来，形成新的活动（可能是进入活动清单，也可以进入今日活动），等之后再做处理；对于外部中断，记录下来，告诉他人稍后再做答复。对于无法延迟的中断，可以立即处理，并且作废当前的番茄钟。 后记《番茄工作法图解》这本书很简洁，篇幅并不长，我阅读它只花了3个番茄（速读了团队相关的章节）。本文只总结了番茄工作法中个人认为重要的一些方面，如果有时间，建议完整的阅读一下这本书，系统的了解一下番茄工作法。 番茄工作法是一个简单又复杂的工具，如果你只是想要用来改善拖延，那么了解了最基本的概念（番茄钟）就可以快速地开始了，使用起来也很简单，不需要依赖过多的外部环境，只需要一个闹钟即可。使用完整的番茄工作法会稍微有些复杂，但拿它来做任务管理和流程复盘，也会有很大的收益。 你可以根据自己的需要，来选择使用简单的番茄工作法，或者使用更完整的番茄工作法。搭建自己的个人时间管理的系统就像完善一个产品，需要不断迭代才能找到最适合自己的方式。 在读这本书的时候，里面提到的一个小观点，我认为值得分享一下：“加班是因为英雄主义和内疚，内疚是因为之前的承诺。这是一种短视的时间管理方式，长远来看，如果能有一个可持续的步伐，我们的生产率会更好。”就像在网上也流行的一句话一样“别让你的努力只是感动了自己”。","tags":["心智"],"categories":["心智"]},{"title":"现代化 Shell 使用指南","path":"/2017/04/23/using-shell-with-the-time/","content":"Shell 作为一个历史悠久的效率工具，它提供了很多方便的工具，提高我们操作计算机的效率。然而被现代各种便利操作熏陶了的我们，可能对一些默认的命令的效率并不满意了。那么如何更好的利用好 Shell 呢？ tl;dr: 一些很好用的命令列表： tldr: 查询一个命令的常用用法 z: 快速目录跳转 fzf: 文件模糊搜索 ag：代码快速搜索 fuck: 自动纠正错误命令 httpie: 更好用的 HTTP 请求工具 htop: top 的升级版 本文只挑选了几个好用的工具来介绍，主要想表达的是现在有很多很好用的 shell 工具，它们比之前的古老版本有不少优势和进步，当你觉得你的某些操作效率不高时，可以考虑去了解一下有没有好的替代方案工具，察觉自己的低效操作并想办法改进总是应该的。 tldr - 命令备忘Linux 下有如此多的命令，有时我们会忘记某个命令的常用方法。这时我们通常会通过 man 或者 Google 来查询命令的用法，但这些结果通常并不简洁明了，我们可能需要花费一些时间来找到我们想要的用法。 tldr 就是为了这种场景而生的，它会很简洁的介绍一个命令，并列出它最常用的一些用法。根据二八法则原理，你很少会用到一些命令的高级用法，常用用法已经可以满足你的需求。你可能经常在某些地方看到「tl;dr」这个缩写，它的意思是“Too long, didn’t read”，意思是就是“文章太长不想看？只看这里就行了”。 首先在 mac 下通过 brew 安装 tldr： # 安装 tldrbrew install tldr# 更新 tldr 的数据tldr --update 使用 tldr： # 查询 find 的常用用法tldr find 结果如下： findFind files under the given directory tree, recursively.- Find files by extension: find root_path -name *.ext- Find files matching path pattern: find root_path -path **/lib/**/*.ext- Run a command for each file, use within the command to access the filename: find root_path -name *.ext -exec wc -l \\;- Find files modified in the last 24-hour period: find root_path -mtime -1- Find files using case insensitive name matching, of a certain size: find root_path -size +500k -size -10MB -iname *.TaR.gZ- Delete files by name, older than 180 days: find root_path -name *.ext -mtime +180 -delete- Find files matching more than one search criteria: find root_path -name *.py -or -name *.r- Find files matching a given pattern, while excluding specific paths: find root_path -name *.py -not -path */site-packages/* 是不是比 man 的结果好用多了。 z - 便捷目录跳转每次跳到常用目录，要输入很长的路径？需要在两个多个目录来回切换？cd 不够好用，pushd/popd/dirs 在一定程度上解决了这个问题，通过将一些目录压到栈中来来回跳转，但还是不够智能。 在这个智能时代，需要一些命令让跳转更加随心所欲，于是一些更加智能的命令被开发出来了。新的命令的主要思路就是，记住你常用的目录，然后等你跳转了一定时间后，就可以用很短的名称（前缀）跳转到常去目录了。 这类工具中比较有名的有 autojump、z、fasd。它们的功能都是类似的，不过整体来说 fasd 功能最强大，不仅支持快速跳转目录，也支持快速打开文件；z 和 autojump 功能基本相同，z 的性能会好一些。我目前主要使用 z。 安装 z： brew install z 在 ~.bash_profile 中增加配置： # z enabled[ -f /usr/local/etc/profile.d/z.sh ] . /usr/local/etc/profile.d/z.sh 这里有一段这些工具的比较： 这类工具中最早的应该是大名鼎鼎的autojump，因为它的快捷命令是j，所以大家也都习惯性地称其为j。autojump使用Python编写，对于Bash和Shell的支持都比较好。但是可能是因为是Python写的吧，有的时候会感觉反应有些慢。 有了j之后，又有了z。z的介绍就是”更好的j”。它的功能和j基本是相同的，不过它使用Shell脚本编写，更加简洁，基本上不会拖慢终端的响应速度。我比较喜欢简洁的，现在看来Github上大部分人也是, z得到了3000+的star，超越了它的前辈autojump。 然后人们还不满足，于是又有了大杀器Fasd，Fasd不光会记录目录，还会记录文件，也就是说它可以做到快捷打开某个深层目录的文件。Fasd还可以通过配置，实现更加高级的功能。Fasd与Zsh的结合也非常好，可以使用tab灵活的在几个目录中选择。可能是由于Fasd太强大了，虽然它使用Shell脚本写的，但是在使用的时候还是会感觉拖慢了终端的速度，特别是在执行ls -l的时候，会感觉输出明显慢了一拍。 —— https://skyline75489.github.io/post/2014-12-13_j-z-and-fasd.html fzf - 快速模糊搜索fzf 是一个很高效的 fuzzy finder，它提供模糊搜索文件夹文件的功能。 首先在 mac 下通过 brew 安装 fzf： # 安装 fzfbrew install fzf# 安装完成 fzf 后，安装 shell 的快捷键支持/usr/local/opt/fzf/install 主要使用场景： 查找文件：直接输入 fzf，或者使用快捷键 ctrl-t 呼出 fzf。使用快捷键调出的时候，前面可以有已经输入的命令，比如 cat ctrl-t。在 fzf 中输入关键字进行模糊搜索，使用 ctrl-p/ctrl-n 来上下选择结果。 查找命令历史：安装 shell 的快捷键支持后，fzf 替换了系统默认的命令搜索 ctrl-r，呼出快捷键不变，使用起来更加好用了。 命令后参数补全：命令参数中使用 **TAB 来触发补全，触发的场景可以参考这里 ag - 代码搜索ag 用来在文件中搜索关键字，是一个类似于 grep、ack 的命令。它的优点有： 比 ack 还要快，这里有一篇效率对比的文章 可以忽略 .gitignore 中的文件 命名更短，短就是效率… 安装 ag： brew install the_silver_searcher 使用方法和 grep 类似，可以用 tldr ag 了解下常用方法： # Find files containing foo, and print the line matches in context:ag foo# Find files containing foo, but only list the filenames:ag -l foo# Find files with a name matching foo:ag -g foo fuck - 命令纠错有时候我们会输错一些命令，比如 git brnch，这时只需要一个简单的命令 fuck，它会根据它预设的模式给出可能的正确命令，用起来就是这么简单粗暴。 安装 thefuck： brew install thefuck 在 ~.bash_profile 中增加配置： eval $(thefuck --alias) httpie - 友好的 HTTP 请求工具httpie 是一个对人类友好的 HTTP 请求模拟器，它的命令参数符合直觉，结果显示的也更清晰。curl 的参数就没那么容易记忆了，总是需要去查手册。 安装 httpie： brew install httpie 一些基本的用法： # GET 访问某页面http example.org# 查看具体的请求头http -v example.org# 带 query string 的请求http www.google.com search==HTTPie logo tbm==isch# 修改请求头http example.org User-Agent:Bacon/1.0 Cookie:valued-visitor=yes;foo=bar X-Foo:Bar htop - 更直观的系统状态htop 可以查看当前系统状态，可以当做是 top 的一个增强版本。它的界面更加直观并且支持鼠标操作，用一下你就知道好在哪里了。 安装 htop： brew install htop glances 又是 htop 的一个升级版，它提供更加详细的信息，并且是 CS 结构的，也就是说你可以监控其他机器的状态。","tags":["工具"],"categories":["技术"]},{"title":"个人的 MacBook 配置","path":"/2016/10/15/personal-macbook-configuration/","content":"写在前面 “工欲善其事，必先利其器”—— 《论语·卫灵公》 我认为 macOS 是一款非常优秀的桌面操作系统，它作为一个 Unix-like 操作系统，对程序开发人员十分友好，然后又有一个精美的桌面系统，和丰富的日常软件生态。能够很好地满足程序开发和日常使用的需要。 那么拿到新的电脑后，如何配置系统？需要安装哪些软件？我分享一下个人的 MacBook 配置，主要站在日常使用和开发编程的角度来进行配置。 系统设置建议拿到电脑后，先升级到最新的系统版本。新电脑升级不容易出现奇怪的问题。通过左上角的苹果图标，选择「About This Mac - Software Update…」来升级系统。 个人常用的一些系统配置。系统配置可以通过左上角的苹果图标下的「System Preferences…」进入。 建议开启的一些触摸板设置： Trackpad - Tap to click：轻拍触摸板来点击，不用每次都按下去 Trackpad - App Exposé：三指下滑在同应用的不同窗口间切换 修改计算机名称为一个可读和简洁的名称： Sharing - Computer Name 禁用 Guest 用户登录： Users Groups - Guest User - Allow guests to log in to this computer：根据需要是否禁用游客账户 设置触发角方便关闭屏幕： Desktop Screen Saver - Hot Corners - Put Display to Sleep：设置当鼠标滑到屏幕的角落时触发屏幕休眠，我通常使用右下角 Dock: Dock - Position on screen - Left：将 Dock 移动到左边，增加可视空间 Dock - Size：适当缩小 Dock，增加可视空间 Dock - Minimize windows into application icon：最小化窗口到其应用上 基础环境V2rayU由于网络问题，部分网站的访问需要科学上网。免费的代理软件，Mac 上推荐使用 V2rayU，iPhone 上可以用 Potatso Lite（需要使用美区账号下载）。 目前连 Homebrew 下载链接都不能访问了，代理还是很有必要的。 HomebrewHomebrew 是 Mac 下最好的包管理软件，相当于 Linux 下的 yum 和 apt-get。使用以下命令安装： /bin/bash -c $(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh) 对于软件安装的一些建议： 对于命令行软件，如果 Homebrew 上有，优先使用 Homebrew 安装。因为使用 brew 安装软件十分方便快捷，后续升级管理也比较方便。 对于图形化软件，可以考虑使用 brew、App Store 或者官网下载安装。 Homebrew 安装软件的一般步骤： brew search 模糊查询是否存在对应的软件 brew info 用完整的名称查看软件的详细信息 brew install 安装软件 认真阅读 install 命令的输出结果，了解软件需要的配置和启动方法 brew upgrade 升级软件到最新版本 输入法考虑到补全和词库，国内的输入法还是比系统自带的要好用一些。可以选择搜狗输入法、QQ输入法或百度输入法。我比较习惯使用搜狗输入法。 使用 Homebrew 安装： brew cask install sogouinput 浏览器平时习惯了使用 Chrome 浏览器，并且在开发者工具方面，Chrome 也做的相对更好一些。 使用 Homebrew 安装： brew search chromebrew info google-chromebrew install google-chrome 文本编辑器VSCode 是微软出品的优秀的编辑器和轻量的 IDE。用来做日常的笔记编写和简单的代码实现都十分舒服。 之前还使用过 Sublime Text 和 Atom（Github 出品），在微软收购了 GitHub 后，已经全面拥抱 VSCode 了。 使用 Homebrew 安装： brew install visual-studio-code 视频播放器Mac 上最佳的视频播放器 IINA，基于 mpv，解码强大，设计风格和功能紧跟最新的 macOS 版本。 使用 Homebrew 安装： brew install iina 开发环境iTerm2开发需要一个好用的终端，Mac 自带的终端功能比较简单，建议使用 ITerm2，支持分屏、补全、查看会有更好的开发体验。 使用 Homebrew 安装： brew install iterm2 终端通常使用频率很高，分享一个可以随时隐藏唤出终端的配置： Keys - HotKey - Showhide all windows with a system-wide hotkey：设置一个全局的快捷键最小化和还原终端窗口 Profiles - Window - Space - All Spaces：当终端窗口还原的时候，可以在任何一个桌面，而不是打开终端的桌面 zshzsh 是一个兼容 bash，并且支持强大的补全和丰富插件的 Shell。 从 macOS Catalina 版开始，zsh 也开始成为了 Mac 的默认 Shell，无需再进行额外的配置，旧版本配置可以参考 Mac 的帮助文档。 Oh My Zshzsh 很强大，但是配置很多很复杂，于是就有了 Oh My Zsh。Oh My Zsh 提供了很多默认的配置、方法、插件和主题，让你的 zsh 可以开箱即用。 安装 Oh My Zsh： sh -c $(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh) 我开启的一些插件，在 ~.zshrc 中添加： plugins=(extract git web-search z zsh_reload) 我使用的主题为 ys，该主题不使用任何特殊符号，该有的信息都有。优点是登陆到任何一台有 zsh 的服务器上，简单的改一下主题，就能获得一致的展示体验。 DotbotDotbot 是一个管理 dotfiles 的工具，相比于其他的 dotfiles 管理方案，它更加简单和直接一些。它直接使用一个 git 仓库来管理你的所有配置文件，并提供一系列简单的命令支持快速在 home 目录下创建软链接的方式来管理。 如果你还不知道 dotfiles 是什么？ Mac 下的各种常用命令和软件的相关配置，通常会存在用户目录下的以 “.” 开头的文件里，dotfiles 就是这些配置文件的概念。当你更换电脑时，只要你备份了你的 dotfiles，就可以快速地回到之前的设置中。关于 dotfiles 的概念和如何管理，可以参考 github 的这份 指引。 tldrtldr 是一个简明的命令帮助，列出了一个命令最常见的用法，并提供了简明的例子来参考。使用命令最常用用法时，比 man 命令方便多了。 使用 Homebrew 安装： brew install tldr 使用方式，比如查看 find 命令的用法： tldr find zz 是一个快速跳转命令，它会学习你常使用的目录，使用一段时间后，就不需要再用 cd 来回跳转了，直接使用 z 加目录的部分名称就可以跳转，十分方便。 如何使用 z： 如果使用 zsh 的话，直接在插件中启用 z 即可。在 ~.zshrc 中增加配置 plugins=(z)。 或者使用 Homebrew 安装 z，命令 brew install z Git程序员必备的版本管理工具了，现在已经成为最主流的版本管理软件。 使用 Homebrew 安装： brew install git 一些简单的基础配置： # 配置提交时的姓名和邮箱git config --global user.name Xuekai Niugit config --global user.email xuekai.niu@gmail.com## 一些有用的别名git config --global alias.lol log --oneline --graph --decorategit config --global alias.hist log --pretty=format:%h %ad | %s%d [%an] --graph --date=short 可以学习一下 git 的常用 workflow，推荐两个不错的教程： Atlassian 的 Git workflow 教程：大名鼎鼎的 Atlassian，开发了 JIRAConfluenceStash 的公司，建议看一下它提供的整套 git 教程，对 git 中比较容易误解的地方都有比较详细的解释。 A successful Git branching model：比较符合实际项目中工程开发的工作流。 高效习惯的思考如何更高效的使用工具？ 选择在使用工具之前，不要着急立刻开始学习它的使用细节，应该花一些时间和精力来调研了解一下有哪类类似的工具，了解一下它们的优缺点。 通常学会一个工具后，你会和它打交道很长的时间，如果你选择了更好的那个，它会在长期提高你的效率。 评判工具的好坏，可以通过功能的完善程度、使用的灵活性、以及社区活跃度等特性。比如对于终端复用器，screen 就比较老旧，功能不够丰富，并且不再活跃开发，应该去了解和学习 tmux。 最佳实践培养自己去了解最佳实践的习惯。 最佳实践是优美的解决方案，是众人的智慧，是大家总结出来的最恰当的用法。可能当你刚开始遵循最佳实践时，不能体会到它的好处，但是它可能悄悄地让你避免了好多的坑。 举一些例子： 使用 brew 来安装和管理软件：你会很少的遇到网上问的各种乱起八糟的环境问题，哪个环境变量没有设置，或者设了一堆自相矛盾的配置项。 语义化版本来命名你的包：你可能不明白这样管理你的包有什么好处，但当你遇到传递性依赖的版本冲突的时候，你会感谢你自己。 可以常搜索一下 ”xxx best practices“ 来了解最佳实践的用法。 积累很多软件的配置很复杂，慢慢积累适合自己的配置，及时备份到云端，不要换个电脑又要重新开始。比如 dotfiles 可以用 dotbot 等工具来管理同步。 但也要适当折中个性化与系统默认配置，至少应该了解系统默认环境的基本操作，防止在其他服务器上效率过低。 反思观察和发现自己存在的低效操作，去网上了解一下有没有更高效的解决方案。发现高效的方案后，刻意的去使用它，直到它成为自己的操作习惯。比如学习一些常用的快捷键，善用 Mac 自带的搜索或一些扩展搜索的软件。","tags":["工具"],"categories":["技术"]},{"title":"关于","path":"/about/index.html","content":"欢迎来到我的博客。 这里是关于博主的一些简单介绍。 关于我互联网行业的后端开发。 联系我 xkniu@Github"},{"title":"探索","path":"/explore/index.html","content":"混沌的地方，没想好放什么。"}]