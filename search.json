[{"title":"Docker 技术概述","path":"/2021/04/09/docker-introduction/","content":"更新（2026-02-03）：基于 Gemini 重新整理文章，使内容更清晰易读。 在软件开发中，有一个经典的痛点：“程序在我电脑里运行得好好的，换个环境怎么就不行了？”这种因环境差异导致的不一致性，曾是开发与运维之间主要的摩擦点。 Docker 通过改变应用的构建、分发与运行方式，系统地解决了这一问题，并逐渐成为现代云计算与微服务架构的基础设施。 一、为什么我们需要 Docker1. 解决分发与部署的一致性Docker 的核心价值在于标准化应用的交付方式。在云原生时代，应用需要摆脱对具体硬件和环境配置的依赖，实现快速迁移与弹性扩展。 传统方式：需要在目标机器上分别安装软件、配置依赖、调整变量。一旦本地与生产环境在内核版本或系统库上存在细微差异，就极易引发错误。 Docker 方式：通过镜像将应用及其完整运行环境整体打包。镜像屏蔽了底层环境差异，部署体验接近“安装即运行”。 2. 容器与虚拟机的技术对比在 Docker 普及之前，虚拟机（VM）是最常见的隔离方案。但虚拟机需要为每个实例运行一套完整的客户操作系统，在资源占用和启动效率上存在劣势。 特性 容器 (Docker) 虚拟机 (VM) 启动时间 秒级 分钟级 镜像体积 KB ~ MB 级别 GB 级别 系统资源损耗 极低 (约 0~5%) 较高 (约 5~15%) 单机支持规模 可运行上千个 通常为几十个 二、核心架构与基础概念Docker 采用典型的客户端-服务器（CS）架构，主要包含以下组件： Docker Daemon (dockerd)：常驻后台的守护进程，负责管理镜像、容器、网络和存储卷。 Docker Client：用户交互入口，负责解析命令并将请求发送给 Daemon。 Docker Registry：镜像仓库，负责集中存储和分发镜像，如 Docker Hub 或私有仓库。 三个基础抽象： Image (镜像)：容器运行的只读模板，包含代码、运行时依赖、系统库及配置。镜像构建后保持不可变。 Container (容器)：镜像的运行时实例。它在只读层之上叠加一个可写层，本质上是运行在受限环境中的进程。 Repository (仓库)：镜像仓库与逻辑集合，负责镜像的集中存储与分发。 三、底层原理：如何保证一致性？为了确保应用在不同环境下行为一致，Docker 重点解决了文件系统与运行隔离两个维度的问题。 1. 文件系统一致性Docker 镜像通过打包 rootfs（根文件系统），固化了应用运行所需的目录结构、配置和系统库。为了提高效率，它引入了 Union FS（联合文件系统）： 分层存储：镜像由多层只读层组成，每一层对应一次构建指令。 层共享：不同镜像可以复用相同的基础层，大幅减少磁盘占用。 写时复制 (CoW)：容器启动后，所有运行时的修改仅作用于最上层的独立可写层，不影响底层镜像。 2. 环境隔离与资源控制Docker 依赖 Linux 内核的两项核心机制来确保容器互不干扰，从而保证执行效果的一致： Namespace (视图隔离)：为进程提供隔离视图，包括 UTS（主机名）、PID（进程编号）、Network（网络栈）、Mount（挂载点）、*IPC- 及 User。这使容器内的进程认为自己拥有独立的操作系统资源。 Cgroups (资源限制)：用于对进程可使用的 CPU、内存、磁盘 IO 等资源进行限制和统计，防止单个容器过度占用资源导致宿主机或其他容器瘫痪。 四、演进：从单机到集群编排随着应用规模的扩大，手动管理容器变得不可行，容器编排工具随之出现： Docker Compose：面向单机环境的多容器编排工具，通过一个 YAML 文件定义完整的应用拓扑，适合本地开发测试。 Docker Swarm：Docker 官方提供的原生集群方案，适合中小规模场景，但在生产中的应用逐渐减少。 Kubernetes (K8s)：行业事实标准。通过 Pod、Service 等抽象，提供自动扩缩容、自愈和滚动更新等强大的集群调度能力。 五、结语Docker 的成功并不在于引入了全新的底层技术，而在于它对 Linux 内核能力的合理组合与抽象，将复杂的隔离机制封装为一套易于使用的应用交付标准。","tags":["技术"],"categories":["技术"]},{"title":"为 Github Pages 绑定域名","path":"/2019/12/31/github-pages-custom-domain/","content":"更新（2020-12-31）：考虑到域名实际使用频率较低，到期后不再续期。 一直用着免费的 Github Pages 搭载个人博客，突然想要一个自己的域名。个人域名的主要优点有： 方便记忆，也就更方便传播 使用别人的二级域名，总是寄人篱下，还是有个自己的一亩三分地比较好 然后就去为博客绑定了个人域名，下面讲述下主要流程。 主要流程如下： 选择一个域名提供商并购买域名 配置 DNS 信息 配置 Github Pages CNAME 信息 购买域名可以选择国内或国外的域名提供商来购买域名，国内通常需要个人实名备案，下面是一些常用的域名商： 国内的域名商：阿里云、腾讯云 国外的域名商：Godaddy、Dynadot 我选择使用 Dynadot 作为我的域名提供商，在主页搜索你想要的域名，如果还没有被他人注册，选择购买即可。 配置 DNS为你的域名配置 DNS 信息。配置域名 DNS 时，有很多种配置方式，我期望的效果是： 使用主域名作为主要的网站地址 www 的子域名重定向到主域名，即访问 www 子域名时，跳转到主域名（浏览器地址中展示主域名） 强行跳转到 HTTPS 域名 以 Dynadot 为例，选择「My Account - My Domains - Manage Domains - Select your domain - DNS Settings - Custom DNS」，然后： 在 Domain Record 下添加一个 CNAME 指向你的 Github Pages 地址 username.github.io 在 Subdomain Records 下添加 Forward 301 记录，将 www 子域名重定向到 https://yourdomain.com 通常主域名是不建议使用 CNAME 跳转的，因为 DNS 规范中返回 CNAME 时，不允许和其他 Resource Record 一起返回，它可能会造成一些问题，详情可以参考这篇文章。但如果你又不想配置 A 记录（改变 IP 时不太方便），你可以使用 ALIAS、ANAME，不过 Dynadot 只支持 CNAME 或者 A 记录，所以我还是选择了配置 CNAME。 配置 Github Pages完成 DNS 的配置后，还需要在你的 Github Pages Repo 中增加一个 CNAME 文件，文件的内容为你使用的域名地址（不要 http 前缀），只能添加一条。例如可以配置为： yourdomain.com Github 会根据你配置的 CNAME，自动为你做 www 子域名的重定向，你也可以使用 DNS 配置的重定向。 感谢 Let’s Encrypt 让我们能够用上开源免费的 HTTPS 证书，Github Pages 也默认对它支持。简单的在 Repo 的「Settings - GitHub Pages - Enforce HTTPS」打钩开启，即可完成 HTTPS 的配置。","tags":["博客"],"categories":["技术"]},{"title":"了解番茄工作法","path":"/2018/11/17/the-pomodoro-technique/","content":"写在前面很早就知道番茄工作法，但一直都没有认真的去了解过。最近想要改善下拖延的习惯，并提高做事的效率，就去读了《番茄工作法图解》一书。 先聊一聊自己最近的状态。通常下班已经很晚了，工作了一整天后，人比较累，很难开始做一些需要思考的事情，很多时候就是漫无目的地看些比较休闲的视频，然后就睡觉了。适当的放松和休息当然是必要的，但是如果在一个很长的时间段，精力都只放在工作中，而不能做一些自己想做的其他事情，会让人感到焦虑，觉得没能做一些有意义的积累。那么如何打破这种惯性，开始做一些想做的事情呢？番茄工作法就是一个很好的工具，它主要有以下的优点： 摆脱拖延。因为懒惰或者完美主义不愿意开始，那么就强行开始。番茄工作法想要培养一种习惯，一种按下按钮，就必须要进行一个25分钟高效周期的习惯。这样高效的做事，就转变成了开启一个番茄，按下一个按钮，变成了一个容易开始的过程。 提高对自我效率的认知。自己要多久才可以做完某件事情？生活中、工作中有大量的场景需要评估一个事情所需要花费的时间代价，了解自己的效率，对制定计划和任务拆解，都有很大的帮助。番茄工作法通过记录和复盘自己在一个番茄内完成的事情，让你逐渐地量化自己的效率。 番茄工作法的理论什么是番茄工作法？简单的讲就是一次只做一件事，每次25分钟，做完就休息。 为什么叫番茄工作法？方法的创立者弗朗西斯科·西里洛在大学的时候，因为自己的效率低下很痛苦，跟自己打赌要“真正的学上10分钟”，就从厨房找了一个计时器，形状好像“番茄”，这就是后来的番茄钟。 为什么要用番茄工作法？番茄工作法有以下的特征优点，或能解决以下的问题： 复杂无聊的琐事完美主义容易造成拖延 按照事情的优先级处理事情 建立一种节奏感，能够拥有的工作休息节奏 记录、处理和可视化，个人流程能够持续改进 增强你做计划的能力，数据化你的效率 它很简单，需要的工具很简单，流程很简单 番茄工作法的一些心理学原理：生物节律、条件与非条件反射、工作记忆、心流、拖延。 怎么应用番茄工作法？番茄工作法实践起来很简单，流程为指定计划-准备环境-吃“番茄”-记录分析修正。更具体的说就是： 从活动清单中选择今天需要完成的任务到今日待办。 从今日待办中选择优先级最高的任务，开始一个番茄钟，并记录一些跟踪信息。 一天结束后，根据记录表格，可视化记录数据，分析流程是否有改进的方式，调整每日的流程。 这是一个戴明循环的流程，一个可以自我优化的循环流程。戴明循环（PDCA 循环）是一种解决问题的周期流程，主要分为4步： 计划（Plan）：定义预期的结果，以及达成它所需的流程。 执行（Do）：实施该流程。 评估（Check）：对流程进行衡量，比较实际结果与预期结果，找出差距。 应用（Action）：对差距进行分析，找出问题根源，以图改进。 番茄工作法只需要一些简单的工具。假如用传统的方式来记录，可以使用一只签字笔、三张白纸和一枚番茄钟即可。三张白纸用途如下： 「今日待办」表格：填写今天的日期和今天需要进行的活动。每天使用一张新的白纸。 「活动清单」表格：列出最近所有需要进行的活动，随便填写，不用排序。一张活动清单可以用很多天，增加新的活动，划掉已完成的活动。 「记录」表格：记录各种流程指标，以便对流程进行改进。一张记录表格可以用很多天，以便比较每天的跟踪信息。 在现在的电子化时代，我选择用一些软件做作为替代品，主要用了下列软件： Apple Calendar：日历是神圣的，主要用来规划一些重要的（必须要做）的事情；不过我专门分出了一个“奇特的一生”日历用来记录流水账，可以记录番茄的信息方便追踪。 Microsoft TODO：用来做任务管理，即取代今日待办和活动清单 Forest：完成一个番茄后种树，可以方便的分类记录和总结回顾，另外看着种出来的森林也是件惬意的事情。 以前内心比较抵制各种激励机制，认为靠理性与自控是更好的方式，现在逐渐接受通过激励、仪式感、趣味性来提高自己的执行力。Permission to be human. Human nature 不是你的敌人，我们应该去接受它，而不是抵制它，用一种更好的方式和它相处（比如学会奖赏你的努力，而不是只依赖自己的自制力）。使用 Forest，每次番茄成功后能种一颗虚拟的树，一点一点种出来一片森林，是一件挺开心的事。 番茄钟是原子的，也就是说一次只做一件事，并且不能被中断。这两个原则可能会遇见一些问题，下面是这些问题和应对方法： 如果提前（番茄钟未结束）做完了手中的事情，可以通过过度学习加强下之前内容的理解，不要在番茄内切换任务。 对于一些很小的零碎任务，可以合并到一个番茄钟内，作为一个整体任务，另外应该减少这种零碎任务番茄。 当遇见中断的时候，对于内部中断，先记录下来，形成新的活动（可能是进入活动清单，也可以进入今日活动），等之后再做处理；对于外部中断，记录下来，告诉他人稍后再做答复。对于无法延迟的中断，可以立即处理，并且作废当前的番茄钟。 后记《番茄工作法图解》这本书很简洁，篇幅并不长，我阅读它只花了3个番茄（速读了团队相关的章节）。本文只总结了番茄工作法中个人认为重要的一些方面，如果有时间，建议完整的阅读一下这本书，系统的了解一下番茄工作法。 番茄工作法是一个简单又复杂的工具，如果你只是想要用来改善拖延，那么了解了最基本的概念（番茄钟）就可以快速地开始了，使用起来也很简单，不需要依赖过多的外部环境，只需要一个闹钟即可。使用完整的番茄工作法会稍微有些复杂，但拿它来做任务管理和流程复盘，也会有很大的收益。 你可以根据自己的需要，来选择使用简单的番茄工作法，或者使用更完整的番茄工作法。搭建自己的个人时间管理的系统就像完善一个产品，需要不断迭代才能找到最适合自己的方式。 在读这本书的时候，里面提到的一个小观点，我认为值得分享一下：“加班是因为英雄主义和内疚，内疚是因为之前的承诺。这是一种短视的时间管理方式，长远来看，如果能有一个可持续的步伐，我们的生产率会更好。”就像在网上也流行的一句话一样“别让你的努力只是感动了自己”。","tags":["心智"],"categories":["心智"]},{"title":"现代化 Shell 使用指南","path":"/2017/04/23/using-shell-with-the-time/","content":"Shell 作为一个历史悠久的效率工具，它提供了很多方便的工具，提高我们操作计算机的效率。然而被现代各种便利操作熏陶了的我们，可能对一些默认的命令的效率并不满意了。那么如何更好的利用好 Shell 呢？ tl;dr: 一些很好用的命令列表： tldr: 查询一个命令的常用用法 z: 快速目录跳转 fzf: 文件模糊搜索 ag：代码快速搜索 fuck: 自动纠正错误命令 httpie: 更好用的 HTTP 请求工具 htop: top 的升级版 本文只挑选了几个好用的工具来介绍，主要想表达的是现在有很多很好用的 shell 工具，它们比之前的古老版本有不少优势和进步，当你觉得你的某些操作效率不高时，可以考虑去了解一下有没有好的替代方案工具，察觉自己的低效操作并想办法改进总是应该的。 tldr - 命令备忘Linux 下有如此多的命令，有时我们会忘记某个命令的常用方法。这时我们通常会通过 man 或者 Google 来查询命令的用法，但这些结果通常并不简洁明了，我们可能需要花费一些时间来找到我们想要的用法。 tldr 就是为了这种场景而生的，它会很简洁的介绍一个命令，并列出它最常用的一些用法。根据二八法则原理，你很少会用到一些命令的高级用法，常用用法已经可以满足你的需求。你可能经常在某些地方看到「tl;dr」这个缩写，它的意思是“Too long, didn’t read”，意思是就是“文章太长不想看？只看这里就行了”。 首先在 mac 下通过 brew 安装 tldr： # 安装 tldrbrew install tldr# 更新 tldr 的数据tldr --update 使用 tldr： # 查询 find 的常用用法tldr find 结果如下： findFind files under the given directory tree, recursively.- Find files by extension: find root_path -name *.ext- Find files matching path pattern: find root_path -path **/lib/**/*.ext- Run a command for each file, use within the command to access the filename: find root_path -name *.ext -exec wc -l \\;- Find files modified in the last 24-hour period: find root_path -mtime -1- Find files using case insensitive name matching, of a certain size: find root_path -size +500k -size -10MB -iname *.TaR.gZ- Delete files by name, older than 180 days: find root_path -name *.ext -mtime +180 -delete- Find files matching more than one search criteria: find root_path -name *.py -or -name *.r- Find files matching a given pattern, while excluding specific paths: find root_path -name *.py -not -path */site-packages/* 是不是比 man 的结果好用多了。 z - 便捷目录跳转每次跳到常用目录，要输入很长的路径？需要在两个多个目录来回切换？cd 不够好用，pushd/popd/dirs 在一定程度上解决了这个问题，通过将一些目录压到栈中来来回跳转，但还是不够智能。 在这个智能时代，需要一些命令让跳转更加随心所欲，于是一些更加智能的命令被开发出来了。新的命令的主要思路就是，记住你常用的目录，然后等你跳转了一定时间后，就可以用很短的名称（前缀）跳转到常去目录了。 这类工具中比较有名的有 autojump、z、fasd。它们的功能都是类似的，不过整体来说 fasd 功能最强大，不仅支持快速跳转目录，也支持快速打开文件；z 和 autojump 功能基本相同，z 的性能会好一些。我目前主要使用 z。 安装 z： brew install z 在 ~.bash_profile 中增加配置： # z enabled[ -f /usr/local/etc/profile.d/z.sh ] . /usr/local/etc/profile.d/z.sh 这里有一段这些工具的比较： 这类工具中最早的应该是大名鼎鼎的autojump，因为它的快捷命令是j，所以大家也都习惯性地称其为j。autojump使用Python编写，对于Bash和Shell的支持都比较好。但是可能是因为是Python写的吧，有的时候会感觉反应有些慢。 有了j之后，又有了z。z的介绍就是”更好的j”。它的功能和j基本是相同的，不过它使用Shell脚本编写，更加简洁，基本上不会拖慢终端的响应速度。我比较喜欢简洁的，现在看来Github上大部分人也是, z得到了3000+的star，超越了它的前辈autojump。 然后人们还不满足，于是又有了大杀器Fasd，Fasd不光会记录目录，还会记录文件，也就是说它可以做到快捷打开某个深层目录的文件。Fasd还可以通过配置，实现更加高级的功能。Fasd与Zsh的结合也非常好，可以使用tab灵活的在几个目录中选择。可能是由于Fasd太强大了，虽然它使用Shell脚本写的，但是在使用的时候还是会感觉拖慢了终端的速度，特别是在执行ls -l的时候，会感觉输出明显慢了一拍。 —— https://skyline75489.github.io/post/2014-12-13_j-z-and-fasd.html fzf - 快速模糊搜索fzf 是一个很高效的 fuzzy finder，它提供模糊搜索文件夹文件的功能。 首先在 mac 下通过 brew 安装 fzf： # 安装 fzfbrew install fzf# 安装完成 fzf 后，安装 shell 的快捷键支持/usr/local/opt/fzf/install 主要使用场景： 查找文件：直接输入 fzf，或者使用快捷键 ctrl-t 呼出 fzf。使用快捷键调出的时候，前面可以有已经输入的命令，比如 cat ctrl-t。在 fzf 中输入关键字进行模糊搜索，使用 ctrl-p/ctrl-n 来上下选择结果。 查找命令历史：安装 shell 的快捷键支持后，fzf 替换了系统默认的命令搜索 ctrl-r，呼出快捷键不变，使用起来更加好用了。 命令后参数补全：命令参数中使用 **TAB 来触发补全，触发的场景可以参考这里 ag - 代码搜索ag 用来在文件中搜索关键字，是一个类似于 grep、ack 的命令。它的优点有： 比 ack 还要快，这里有一篇效率对比的文章 可以忽略 .gitignore 中的文件 命名更短，短就是效率… 安装 ag： brew install the_silver_searcher 使用方法和 grep 类似，可以用 tldr ag 了解下常用方法： # Find files containing foo, and print the line matches in context:ag foo# Find files containing foo, but only list the filenames:ag -l foo# Find files with a name matching foo:ag -g foo fuck - 命令纠错有时候我们会输错一些命令，比如 git brnch，这时只需要一个简单的命令 fuck，它会根据它预设的模式给出可能的正确命令，用起来就是这么简单粗暴。 安装 thefuck： brew install thefuck 在 ~.bash_profile 中增加配置： eval $(thefuck --alias) httpie - 友好的 HTTP 请求工具httpie 是一个对人类友好的 HTTP 请求模拟器，它的命令参数符合直觉，结果显示的也更清晰。curl 的参数就没那么容易记忆了，总是需要去查手册。 安装 httpie： brew install httpie 一些基本的用法： # GET 访问某页面http example.org# 查看具体的请求头http -v example.org# 带 query string 的请求http www.google.com search==HTTPie logo tbm==isch# 修改请求头http example.org User-Agent:Bacon/1.0 Cookie:valued-visitor=yes;foo=bar X-Foo:Bar htop - 更直观的系统状态htop 可以查看当前系统状态，可以当做是 top 的一个增强版本。它的界面更加直观并且支持鼠标操作，用一下你就知道好在哪里了。 安装 htop： brew install htop glances 又是 htop 的一个升级版，它提供更加详细的信息，并且是 CS 结构的，也就是说你可以监控其他机器的状态。","tags":["工具"],"categories":["技术"]},{"title":"个人的 MacBook 配置","path":"/2016/10/15/personal-macbook-configuration/","content":"写在前面 “工欲善其事，必先利其器”—— 《论语·卫灵公》 我认为 macOS 是一款非常优秀的桌面操作系统，它作为一个 Unix-like 操作系统，对程序开发人员十分友好，然后又有一个精美的桌面系统，和丰富的日常软件生态。能够很好地满足程序开发和日常使用的需要。 那么拿到新的电脑后，如何配置系统？需要安装哪些软件？我分享一下个人的 MacBook 配置，主要站在日常使用和开发编程的角度来进行配置。 系统设置建议拿到电脑后，先升级到最新的系统版本。新电脑升级不容易出现奇怪的问题。通过左上角的苹果图标，选择「About This Mac - Software Update…」来升级系统。 个人常用的一些系统配置。系统配置可以通过左上角的苹果图标下的「System Preferences…」进入。 建议开启的一些触摸板设置： Trackpad - Tap to click：轻拍触摸板来点击，不用每次都按下去 Trackpad - App Exposé：三指下滑在同应用的不同窗口间切换 修改计算机名称为一个可读和简洁的名称： Sharing - Computer Name 禁用 Guest 用户登录： Users Groups - Guest User - Allow guests to log in to this computer：根据需要是否禁用游客账户 设置触发角方便关闭屏幕： Desktop Screen Saver - Hot Corners - Put Display to Sleep：设置当鼠标滑到屏幕的角落时触发屏幕休眠，我通常使用右下角 Dock: Dock - Position on screen - Left：将 Dock 移动到左边，增加可视空间 Dock - Size：适当缩小 Dock，增加可视空间 Dock - Minimize windows into application icon：最小化窗口到其应用上 基础环境V2rayU由于网络问题，部分网站的访问需要科学上网。免费的代理软件，Mac 上推荐使用 V2rayU，iPhone 上可以用 Potatso Lite（需要使用美区账号下载）。 目前连 Homebrew 下载链接都不能访问了，代理还是很有必要的。 HomebrewHomebrew 是 Mac 下最好的包管理软件，相当于 Linux 下的 yum 和 apt-get。使用以下命令安装： /bin/bash -c $(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh) 对于软件安装的一些建议： 对于命令行软件，如果 Homebrew 上有，优先使用 Homebrew 安装。因为使用 brew 安装软件十分方便快捷，后续升级管理也比较方便。 对于图形化软件，可以考虑使用 brew、App Store 或者官网下载安装。 Homebrew 安装软件的一般步骤： brew search 模糊查询是否存在对应的软件 brew info 用完整的名称查看软件的详细信息 brew install 安装软件 认真阅读 install 命令的输出结果，了解软件需要的配置和启动方法 brew upgrade 升级软件到最新版本 输入法考虑到补全和词库，国内的输入法还是比系统自带的要好用一些。可以选择搜狗输入法、QQ输入法或百度输入法。我比较习惯使用搜狗输入法。 使用 Homebrew 安装： brew cask install sogouinput 浏览器平时习惯了使用 Chrome 浏览器，并且在开发者工具方面，Chrome 也做的相对更好一些。 使用 Homebrew 安装： brew search chromebrew info google-chromebrew install google-chrome 文本编辑器VSCode 是微软出品的优秀的编辑器和轻量的 IDE。用来做日常的笔记编写和简单的代码实现都十分舒服。 之前还使用过 Sublime Text 和 Atom（Github 出品），在微软收购了 GitHub 后，已经全面拥抱 VSCode 了。 使用 Homebrew 安装： brew install visual-studio-code 视频播放器Mac 上最佳的视频播放器 IINA，基于 mpv，解码强大，设计风格和功能紧跟最新的 macOS 版本。 使用 Homebrew 安装： brew install iina 开发环境iTerm2开发需要一个好用的终端，Mac 自带的终端功能比较简单，建议使用 ITerm2，支持分屏、补全、查看会有更好的开发体验。 使用 Homebrew 安装： brew install iterm2 终端通常使用频率很高，分享一个可以随时隐藏唤出终端的配置： Keys - HotKey - Showhide all windows with a system-wide hotkey：设置一个全局的快捷键最小化和还原终端窗口 Profiles - Window - Space - All Spaces：当终端窗口还原的时候，可以在任何一个桌面，而不是打开终端的桌面 zshzsh 是一个兼容 bash，并且支持强大的补全和丰富插件的 Shell。 从 macOS Catalina 版开始，zsh 也开始成为了 Mac 的默认 Shell，无需再进行额外的配置，旧版本配置可以参考 Mac 的帮助文档。 Oh My Zshzsh 很强大，但是配置很多很复杂，于是就有了 Oh My Zsh。Oh My Zsh 提供了很多默认的配置、方法、插件和主题，让你的 zsh 可以开箱即用。 安装 Oh My Zsh： sh -c $(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh) 我开启的一些插件，在 ~.zshrc 中添加： plugins=(extract git web-search z zsh_reload) 我使用的主题为 ys，该主题不使用任何特殊符号，该有的信息都有。优点是登陆到任何一台有 zsh 的服务器上，简单的改一下主题，就能获得一致的展示体验。 DotbotDotbot 是一个管理 dotfiles 的工具，相比于其他的 dotfiles 管理方案，它更加简单和直接一些。它直接使用一个 git 仓库来管理你的所有配置文件，并提供一系列简单的命令支持快速在 home 目录下创建软链接的方式来管理。 如果你还不知道 dotfiles 是什么？ Mac 下的各种常用命令和软件的相关配置，通常会存在用户目录下的以 “.” 开头的文件里，dotfiles 就是这些配置文件的概念。当你更换电脑时，只要你备份了你的 dotfiles，就可以快速地回到之前的设置中。关于 dotfiles 的概念和如何管理，可以参考 github 的这份 指引。 tldrtldr 是一个简明的命令帮助，列出了一个命令最常见的用法，并提供了简明的例子来参考。使用命令最常用用法时，比 man 命令方便多了。 使用 Homebrew 安装： brew install tldr 使用方式，比如查看 find 命令的用法： tldr find zz 是一个快速跳转命令，它会学习你常使用的目录，使用一段时间后，就不需要再用 cd 来回跳转了，直接使用 z 加目录的部分名称就可以跳转，十分方便。 如何使用 z： 如果使用 zsh 的话，直接在插件中启用 z 即可。在 ~.zshrc 中增加配置 plugins=(z)。 或者使用 Homebrew 安装 z，命令 brew install z Git程序员必备的版本管理工具了，现在已经成为最主流的版本管理软件。 使用 Homebrew 安装： brew install git 一些简单的基础配置： # 配置提交时的姓名和邮箱git config --global user.name Xuekai Niugit config --global user.email xuekai.niu@gmail.com## 一些有用的别名git config --global alias.lol log --oneline --graph --decorategit config --global alias.hist log --pretty=format:%h %ad | %s%d [%an] --graph --date=short 可以学习一下 git 的常用 workflow，推荐两个不错的教程： Atlassian 的 Git workflow 教程：大名鼎鼎的 Atlassian，开发了 JIRAConfluenceStash 的公司，建议看一下它提供的整套 git 教程，对 git 中比较容易误解的地方都有比较详细的解释。 A successful Git branching model：比较符合实际项目中工程开发的工作流。 高效习惯的思考如何更高效的使用工具？ 选择在使用工具之前，不要着急立刻开始学习它的使用细节，应该花一些时间和精力来调研了解一下有哪类类似的工具，了解一下它们的优缺点。 通常学会一个工具后，你会和它打交道很长的时间，如果你选择了更好的那个，它会在长期提高你的效率。 评判工具的好坏，可以通过功能的完善程度、使用的灵活性、以及社区活跃度等特性。比如对于终端复用器，screen 就比较老旧，功能不够丰富，并且不再活跃开发，应该去了解和学习 tmux。 最佳实践培养自己去了解最佳实践的习惯。 最佳实践是优美的解决方案，是众人的智慧，是大家总结出来的最恰当的用法。可能当你刚开始遵循最佳实践时，不能体会到它的好处，但是它可能悄悄地让你避免了好多的坑。 举一些例子： 使用 brew 来安装和管理软件：你会很少的遇到网上问的各种乱起八糟的环境问题，哪个环境变量没有设置，或者设了一堆自相矛盾的配置项。 语义化版本来命名你的包：你可能不明白这样管理你的包有什么好处，但当你遇到传递性依赖的版本冲突的时候，你会感谢你自己。 可以常搜索一下 ”xxx best practices“ 来了解最佳实践的用法。 积累很多软件的配置很复杂，慢慢积累适合自己的配置，及时备份到云端，不要换个电脑又要重新开始。比如 dotfiles 可以用 dotbot 等工具来管理同步。 但也要适当折中个性化与系统默认配置，至少应该了解系统默认环境的基本操作，防止在其他服务器上效率过低。 反思观察和发现自己存在的低效操作，去网上了解一下有没有更高效的解决方案。发现高效的方案后，刻意的去使用它，直到它成为自己的操作习惯。比如学习一些常用的快捷键，善用 Mac 自带的搜索或一些扩展搜索的软件。","tags":["工具"],"categories":["技术"]},{"title":"关于","path":"/about/index.html","content":"我总喜欢在浏览别人的博客时先看“关于”，来知道他们是谁，在想些什么。对我来说，“关于”页面就像是一页极简的人生记录，记录一个人的经历和想法。所以，我也在这里留下我的记录。 90 后 河南出生 现居上海 华中科技大学 · 软件工程 后端开发：百世、蚂蚁、Shopee、美团 历经北上深杭，在城市间兜兜转转寻找落脚点 长期主义：跑步 投资 (FIRE) 家庭 关于博客 2025-08-19：切换为 Stellar 主题 2019-12-31：博客迁移至 Hexo，采用 NexT 主题 2016-10-15：基于 GitHub Pages 与 Jekyll 搭建个人博客"},{"title":"探索","path":"/explore/index.html","content":"混沌的地方，没想好放什么。"}]